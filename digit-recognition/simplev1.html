<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digit Recognition</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
    <div class="page-narrow">
        <a href="./" class="nav-link">Back to main page</a>
        <h1>Digit Recognition <span class="model-badge inline">Simple v1</span></h1>
        <p>Draw a digit (0-9) and click "Recognize".</p>

        <div>
            <canvas id="drawCanvas" width="28" height="28"></canvas>
            <div class="canvas-label">28×28 pixels (scaled 10× for display)</div>
        </div>

        <div class="buttons">
            <button id="recognizeBtn" disabled>Recognize</button>
            <button id="clearBtn">Clear</button>
        </div>

        <div class="result">
            <div>Prediction: <span class="prediction-value" id="prediction">?</span></div>
            <div id="confidence"></div>
            
            <div class="probabilities" id="probabilities"></div>
        </div>

        <script>
            // ============================================================
            // ONNX Runtime Inference
            // ============================================================
            
            let session = null;

            function softmax(x) {
                const maxVal = Math.max(...x);
                const exps = x.map(v => Math.exp(v - maxVal));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps.map(v => v / sum);
            }

            async function runInference(inputData) {
                // Create tensor with shape [1, 28, 28] (batch, height, width)
                const tensor = new ort.Tensor('float32', inputData, [1, 28, 28]);
                
                // Run inference
                const results = await session.run({ image: tensor });
                
                // Get output logits
                return Array.from(results.logits.data);
            }

            // ============================================================
            // Canvas Drawing
            // ============================================================

            const canvas = document.getElementById('drawCanvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            function clearCanvas() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                document.getElementById('prediction').textContent = '?';
                document.getElementById('confidence').textContent = '';
                updateProbabilityBars([]);
            }

            clearCanvas();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            function getPos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                if (e.touches) {
                    return {
                        x: (e.touches[0].clientX - rect.left) * scaleX,
                        y: (e.touches[0].clientY - rect.top) * scaleY
                    };
                }
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            function startDrawing(e) {
                isDrawing = true;
                const pos = getPos(e);
                lastX = pos.x;
                lastY = pos.y;
                ctx.beginPath();
                ctx.arc(lastX, lastY, ctx.lineWidth / 2, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            }

            function draw(e) {
                if (!isDrawing) return;
                e.preventDefault();
                
                const pos = getPos(e);
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();
                
                lastX = pos.x;
                lastY = pos.y;
            }

            function stopDrawing() {
                isDrawing = false;
            }

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', stopDrawing);

            // ============================================================
            // Image Processing & Inference
            // ============================================================

            function getImageData() {
                const imageData = ctx.getImageData(0, 0, 28, 28);
                const pixels = imageData.data;
                
                // Convert to Float32Array for ONNX (784 values, normalized 0-1)
                const input = new Float32Array(784);
                for (let i = 0; i < 784; i++) {
                    input[i] = pixels[i * 4] / 255.0;
                }
                
                return input;
            }

            function updateProbabilityBars(probs) {
                const container = document.getElementById('probabilities');
                
                if (probs.length === 0) {
                    container.innerHTML = Array.from({length: 10}, (_, i) => `
                        <div class="prob-row">
                            <span class="digit">${i}</span>
                            <div class="bar-bg"><div class="bar" style="width: 0%"></div></div>
                            <span class="pct">-</span>
                        </div>
                    `).join('');
                    return;
                }

                const maxIdx = probs.indexOf(Math.max(...probs));
                
                container.innerHTML = probs.map((p, i) => `
                    <div class="prob-row">
                        <span class="digit">${i}</span>
                        <div class="bar-bg"><div class="bar ${i === maxIdx ? 'top' : ''}" style="width: ${(p * 100).toFixed(1)}%"></div></div>
                        <span class="pct">${(p * 100).toFixed(1)}%</span>
                    </div>
                `).join('');
            }

            async function recognize() {
                if (!session) {
                    alert('Model not loaded yet!');
                    return;
                }

                const input = getImageData();
                const logits = await runInference(input);
                const probs = softmax(logits);
                
                let maxIdx = 0;
                let maxVal = probs[0];
                for (let i = 1; i < probs.length; i++) {
                    if (probs[i] > maxVal) {
                        maxVal = probs[i];
                        maxIdx = i;
                    }
                }

                document.getElementById('prediction').textContent = maxIdx;
                document.getElementById('confidence').textContent = 
                    `Confidence: ${(maxVal * 100).toFixed(1)}%`;
                
                updateProbabilityBars(probs);
            }

            // ============================================================
            // Initialization
            // ============================================================

            document.getElementById('recognizeBtn').addEventListener('click', recognize);
            document.getElementById('clearBtn').addEventListener('click', clearCanvas);

            updateProbabilityBars([]);

            // Load ONNX model
            ort.InferenceSession.create('assets/simplev1/model.onnx')
                .then(s => {
                    session = s;
                    document.getElementById('recognizeBtn').disabled = false;
                })
                .catch(err => {
                    console.error('Failed to load model:', err);
                    alert('Failed to load model. See console for details.');
                });
        </script>
        <p>Visualizations and analysis available <a href="assets/simplev1/visualizations/visualizations/visualization.html">here</a>.</p>
        <h2>Background</h2>
        <p>
            I trained a neural network using very naive methods on the free <a href="https://www.kaggle.com/datasets/hojjatk/mnist-dataset?resource=download">MNIST dataset of labeled handwritten digits</a>
            The dataset itself is split between training and testing data.
        </p>
        <p>
            Here is the repo for training and testing the model checkpointed at the version used in this page:
            <a href="https://github.com/xkjjx/basic-digit-recognition/tree/simple-version-checkpoint-1">https://github.com/xkjjx/basic-digit-recognition/tree/simple-version-checkpoint-1</a>.
        </p>
        <p>
            As you can easily tell, the model is extremely confident and not very accurate.
            It is likely heavily overfitted to the training data.
            Despite that, the model scores highly in the test dataset as well, scoring an accuracy of 98.03%.
            I ran 100 epochs 3 separate times for a total of 300 epochs.
        </p>
    </div>
</body>
</html>
