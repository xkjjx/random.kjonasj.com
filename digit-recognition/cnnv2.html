<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digit Recognition</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
</head>
<body>
    <div class="page-narrow">
        <a href="./" class="nav-link">Back to main page</a>
        <h1>CNN Digit Recognition <span class="model-badge inline">CNN v2</span></h1>
        <p>Draw a digit (0-9) and click "Recognize".</p>

        <div>
            <canvas id="drawCanvas" width="28" height="28"></canvas>
            <div class="canvas-label">28×28 pixels (scaled 10× for display)</div>
        </div>

        <div class="buttons">
            <button id="recognizeBtn" disabled>Recognize</button>
            <button id="clearBtn">Clear</button>
        </div>

        <div class="result">
            <div>Prediction: <span class="prediction-value" id="prediction">?</span></div>
            <div id="confidence"></div>

            <div class="probabilities" id="probabilities"></div>
        </div>

        <script>
            let session = null;

            function softmax(x) {
                const maxVal = Math.max(...x);
                const exps = x.map(v => Math.exp(v - maxVal));
                const sum = exps.reduce((a, b) => a + b, 0);
                return exps.map(v => v / sum);
            }

            async function runInference(inputData) {
                const tensor = new ort.Tensor('float32', inputData, [1, 1, 28, 28]);
                const results = await session.run({ image: tensor });
                return Array.from(results.logits.data);
            }

            const canvas = document.getElementById('drawCanvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            function clearCanvas() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                document.getElementById('prediction').textContent = '?';
                document.getElementById('confidence').textContent = '';
                updateProbabilityBars([]);
            }

            clearCanvas();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            function getPos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                if (e.touches) {
                    return {
                        x: (e.touches[0].clientX - rect.left) * scaleX,
                        y: (e.touches[0].clientY - rect.top) * scaleY
                    };
                }
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

            function startDrawing(e) {
                isDrawing = true;
                const pos = getPos(e);
                lastX = pos.x;
                lastY = pos.y;
                ctx.beginPath();
                ctx.arc(lastX, lastY, ctx.lineWidth / 2, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();
            }

            function draw(e) {
                if (!isDrawing) return;
                e.preventDefault();

                const pos = getPos(e);
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(pos.x, pos.y);
                ctx.stroke();

                lastX = pos.x;
                lastY = pos.y;
            }

            function stopDrawing() {
                isDrawing = false;
            }

            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            canvas.addEventListener('touchstart', startDrawing);
            canvas.addEventListener('touchmove', draw);
            canvas.addEventListener('touchend', stopDrawing);

            function getImageData() {
                const imageData = ctx.getImageData(0, 0, 28, 28);
                const pixels = imageData.data;

                const input = new Float32Array(784);
                for (let i = 0; i < 784; i++) {
                    input[i] = pixels[i * 4] / 255.0;
                }

                return input;
            }

            function updateProbabilityBars(probs) {
                const container = document.getElementById('probabilities');

                if (probs.length === 0) {
                    container.innerHTML = Array.from({length: 10}, (_, i) => `
                        <div class="prob-row">
                            <span class="digit">${i}</span>
                            <div class="bar-bg"><div class="bar" style="width: 0%"></div></div>
                            <span class="pct">-</span>
                        </div>
                    `).join('');
                    return;
                }

                const maxIdx = probs.indexOf(Math.max(...probs));

                container.innerHTML = probs.map((p, i) => `
                    <div class="prob-row">
                        <span class="digit">${i}</span>
                        <div class="bar-bg"><div class="bar ${i === maxIdx ? 'top' : ''}" style="width: ${(p * 100).toFixed(1)}%"></div></div>
                        <span class="pct">${(p * 100).toFixed(1)}%</span>
                    </div>
                `).join('');
            }

            async function recognize() {
                if (!session) {
                    alert('Model not loaded yet!');
                    return;
                }

                const input = getImageData();
                const logits = await runInference(input);
                const probs = softmax(logits);

                let maxIdx = 0;
                let maxVal = probs[0];
                for (let i = 1; i < probs.length; i++) {
                    if (probs[i] > maxVal) {
                        maxVal = probs[i];
                        maxIdx = i;
                    }
                }

                document.getElementById('prediction').textContent = maxIdx;
                document.getElementById('confidence').textContent =
                    `Confidence: ${(maxVal * 100).toFixed(1)}%`;

                updateProbabilityBars(probs);
            }

            document.getElementById('recognizeBtn').addEventListener('click', recognize);
            document.getElementById('clearBtn').addEventListener('click', clearCanvas);

            updateProbabilityBars([]);

            ort.InferenceSession.create('assets/cnnv2/model.onnx')
                .then(s => {
                    session = s;
                    document.getElementById('recognizeBtn').disabled = false;
                })
                .catch(err => {
                    console.error('Failed to load model:', err);
                    alert('Failed to load model. See console for details.');
                });
        </script>
        <h2>Background</h2>
        <p>
            CNN trained on <a href="https://www.kaggle.com/datasets/hojjatk/mnist-dataset">MNIST</a>,
            training notebook: <a href="https://www.kaggle.com/code/kevinjonas/cnnv2">kaggle.com/code/kevinjonas/cnnv2</a>.
        </p>
    </div>
</body>
</html>
